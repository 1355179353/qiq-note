import{_ as l,o as e,c as o,a as n,z as s,O as a}from"./chunks/framework.16bbc80c.js";const J=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"solution/resource-cache.md","filePath":"solution/resource-cache.md"}'),p={name:"solution/resource-cache.md"},t=s("h1",null,"解决系统资源缓存问题的技术方案",-1),c=s("h3",null,"一、背景",-1),r=s("br",null,null,-1),i=s("h4",null,"1.1 缓存的优点：",-1),h=s("br",null,null,-1),u=s("br",null,null,-1),D=s("h4",null,"1.2 缓存的缺点：",-1),y=s("h3",null,"二、解决方案",-1),d=s("br",null,null,-1),_=s("h4",null,"2.1 原理：",-1),b=s("br",null,null,-1),F=s("br",null,null,-1),C=s("h4",null,"2.2 方案一：hash",-1),m=a("",5),A=a("",5),f=a("",5),E=s("br",null,null,-1),g=s("br",null,null,-1),T=s("h4",null,"3.1 强缓存",-1),k=s("div",{class:"tip custom-block"},[s("p",{class:"custom-block-title"},"例如："),s("p",null,[n("•no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。"),s("br"),n(" •no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。"),s("br"),n(" •public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。"),s("br"),n(" •private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。")])],-1),v=s("p",null,"    Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。",-1),M=s("h4",null,"3.2 协商缓存",-1),S=s("br",null,null,-1),j=s("br",null,null,-1),x=s("h4",null,"Last-Modify/If-Modify-Since",-1),I=s("br",null,null,-1),N=s("br",null,null,-1),L=s("h4",null,"ETag/If-None-Match",-1),P=s("div",{class:"warning custom-block"},[s("p",{class:"custom-block-title"},"注意："),s("p",null,"Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。")],-1);function w(V,q,$,B,R,O){return e(),o("div",null,[t,c,r,i,n("     为了提升系统的性能和用户体验，系统开发时一般会在 nginx 中配置资源缓存，这样用户就不需要每次访问系统时都要把文件、图片、js、css 等资源都重新加载一遍了，资源缓存可以有效的加快用户在非首次访问我们系统时的加载速度，提升用户体验。"),h,u,D,n("     设置了资源缓存之后，当我们的系统上线了新的需求，用户需要强制刷新浏览器才能看到新的功能（原因可以查看章节三、强缓存和协商缓存），会降低用户体验，同时也增加客户经理和运维人员的对客解释成本。 "),y,d,_,n("     浏览器只会缓存加载过的资源，并且每次都会加载新的资源； 我们可以在项目打包时通过给文件名加上随机的 hash 值，然后在文件有改动时更新 hash 值，让浏览器器把这些 hash 有变化的文件当成新的资源，这样浏览器就会绕过缓存重新加载了。 给资源文件加 hash 值的方法有如下三种，各有优点和应用场景。"),b,F,C,n("     hash 是项目级别的，一个项目只有一个 hash 值，即所有文件 hash 相同，如果任意文件内容发生变化，则再次打包后，所有文件的 hash 均改变且相同。 "),m,n("     根据不同的入口文(Entry)进行依赖文件解析，构建对应的 chunk，生成对应的哈希值。例如我们会把一些公共库入口文件和程序入口文件区分开，单独打包构建，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响，提升了打包效率和加载速度。 "),A,n("     contenthash 是针对文件内容级别的，只有你自己模块的内容变了，那么 hash 值才改变。 "),f,n("     缓存是指代理服务器或客户端磁盘内保存的资源副本。利用缓存可减少对服务器的访问，因此也就节省了通信流量和通信时间。浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。"),E,g,T,n("     强缓存是利用 http 的返回头中的 Expires 或者 Cache-Control 两个字段来控制的，用来表示资源的缓存时间。 Expires这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control Cache-Control 是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值： "),k,v,M,n("     协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组 header 字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified 或者 Etag），则后续请求则会带上对应的请求字段（If-Modified-Since 或者 If-None-Match），若响应头没有 Last-Modified 或者 Etag 字段，则请求头也不会有对应的字段。"),S,j,x,n("     浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modified，Last-Modified 是一个时间，标识该资源的最后修改时间。 当浏览器再次请求该资源时，request 的请求头中会包含 If-Modified-Since，该值为缓存之前返回的 Last-Modified。服务器收到 If-Modified-Since 后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modified。"),I,N,L,n("     与 Last-Modified/If-Modified-Since 不同的是，Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器发送的 If-None-Match 值来判断是否命中缓存。 "),P])}const G=l(p,[["render",w]]);export{J as __pageData,G as default};
